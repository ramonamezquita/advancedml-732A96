---
title: "Lab 2"
output:
  pdf_document:
    latex_engine: xelatex

---
```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.width=4, fig.height=3, out.extra='trim=0 20 0 50,clip')
```

## Task 1

In the first task we simple defined and created a hidden markov  model matching the description of the task.
The hidden and emission states were defined, as well as the transition and emmission probabilities. 
The hidden markov model was created with these definitions using the HMM package and the initHMM function

```{r Task 1, warning = FALSE, message = FALSE, fig.show='hide'}
library(HMM)

#Define the hidden states
states <- paste0("", 1:10)  
#Define the emission states
symbols <- paste0("", 1:10)


#transition probabilities, 
transProbs <- matrix(0, nrow = 10, ncol = 10)

#Define for each row the transition probabilities from the current state 
#(the number of the row), to the next (the number of the column)
for(i in 1:10){
  transProbs[i,i] <- 0.5
  next_sector <- ifelse(i == 10, 1, i + 1)
  transProbs[i, next_sector] <- 0.5 
}

#emmision probabilities
emissionProbs <- matrix(0, nrow = 10, ncol = 10)

#define the emission probabilities from the hidden state (number of the row), 
#to the emmision state (number of the column)
for(i in 1:10){
  indices <- ((i - 2):(i + 2)) %% 10 #use modulo for wrap around
  indices[indices == 0] <- 10  # replace 0 with 10
  emissionProbs[i, indices] <- 1 / length(indices)
}

#Define the start probabilities
startProbs <- rep(1/10, 10)

#Define the hidden markow model
hmm <- initHMM(States = states, Symbols = symbols,
               startProbs = startProbs,
               transProbs = transProbs,
               emissionProbs = emissionProbs)
```


# Task 2

A 100 steps are simulated from the defined markov model

```{r Task 2, warning = FALSE, message = FALSE, fig.show='hide'}


# Simulate 100 observations
sim <- simHMM(hmm, 100)

```


The emission probabilities were extracted to give the posterior distribution of the hidden state at each time step given the observed emission states of the run from task 3. The posterior was calculated by combining the posterior distributions calculated from the forward and the backward algorithm
```{r Task 3, warning = FALSE, message = FALSE, fig.show='hide'}

#extract the emission states only
observations <- as.integer(sim$observation)

#Get the log posterior probabilities
logAlpha <- forward(hmm, observations)
logBeta <- backward(hmm, observations)


#convert to probabilities
alpha <- exp(logAlpha)
beta <- exp(logBeta)

#calculate the posterior distribution for zt at every t
posterior <- alpha * beta
posterior <- posterior / colSums(posterior)



```
